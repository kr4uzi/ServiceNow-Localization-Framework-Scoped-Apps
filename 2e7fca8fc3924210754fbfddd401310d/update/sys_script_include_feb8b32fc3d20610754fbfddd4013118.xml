<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_376096_lfp_apps.MetadataLocalizationProcessor</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Script that is used while processing or translating an artifact</description>
        <name>MetadataLocalizationProcessor</name>
        <script><![CDATA[ /* global gs, global, x_376096_lfp_apps */
 /* global Class, GlideAggregate, GlideRecord, GlideTableHierarchy, GlideScriptedExtensionPoint, Set */
/* eslint no-undef: "error" */
var MetadataLocalizationProcessor = Class.create();
MetadataLocalizationProcessor.prototype = Object.extendsObject(global.LFArtifactProcessorSNC, {
	initialize: function () {
		global.LFArtifactProcessorSNC.prototype.initialize.apply(this, arguments);
		
		const extensionPoints = new GlideScriptedExtensionPoint().getExtensions('LFPMetadataExt');
		if (extensionPoints.length) {
			for (let i = 0; i < extensionPoints.length; i++) {
				extensionPoints[i].initialize();
			}

			this.extensionPoints = extensionPoints;
		} else {
			throw new Error(this.type + ' requires a "LFPMetadataExt" implementation');
		}

		this.documentationProcessor = new x_376096_lfp_apps.TableLocalizationProcessor();
		this.metadataHandlers = {
			'sys_ui_section': this._processUISection,
			'sys_db_object': this._processDocumentation
		};

		new GlideTableHierarchy('sys_dictionary').getAllExtensions().forEach(x => {
			this.metadataHandlers[x] = this._processDocumentation;
		});
	},
	
	showTranslateUIAction: function (recordGr) {
		const recordTable = recordGr.getRecordClassName();
		if (new global.LFUtils().showUIAction('lfp_apps_metadata')
			&& this._getTranslateableFields(recordTable).length > 0) {
			const uiActionGr = new GlideRecord('sys_ui_action');
			uiActionGr.addQuery('sys_id', '!=', '08d5d8ffc3560610754fbfddd4013158');
			uiActionGr.addQuery('active', true);
			uiActionGr.addQuery('name', 'Edit Translations');
			uiActionGr.addQuery('table', 'IN', new GlideTableHierarchy(recordTable).getTables());
			uiActionGr.setLimit(1);
			uiActionGr.query();
			// only show the translate ui action if no other 'Edit Translations' UI Action exists for the record's table
			return !uiActionGr.hasNext();
		}
		
		return false;
	},

    getTranslatableContent: function(params) {
		const builder = new global.LFDocumentContentBuilder('v1', params.language, params.sysId, params.tableName, params);
		const ext = this._extForTable(params.tableName);
		if (ext) {
			// Note: Not accessing the record's table is intentional to avoid creating cross scope privileges
			const recordGr = new GlideRecord('sys_metadata');
			recordGr.addQuery('sys_id', params.sysId);
			recordGr.setLimit(1);
			recordGr.query();
			if (recordGr.next()) {
				const displayValue = recordGr.getClassDisplayValue() + ': ' + (recordGr.getDisplayValue() || params.sysId);
				const scope = recordGr.getValue('sys_scope');

				const scriptFields = this._getScriptFields(params.tableName);
				const htmlFields = this._getHTMLFields(params.tableName);
				const fields = scriptFields.map(f => f.name)
					.concat(htmlFields.map(f => f.name));

				builder.processTranslatableFieldsForMultipleRecords(params.tableName, 'sys_id=' + params.sysId, displayValue, params) 
				const data = ext.getFieldValues(params.tableName, recordGr.getUniqueValue(), fields);
				if (data) {
					scriptFields.forEach(f => builder.processScript(data[f.name], displayValue, f.label, params));
					htmlFields.forEach(f => {
						const messages = this._processHTML(data[f.name]);
						builder.processStringArray(messages, displayValue, f.label, params);
					});
				}

				this.metadataHandlers[params.tableName]?.call(this, builder, recordGr, displayValue, params);
			} else {
				gs.error('LF+ Scoped Apps: No Extension Point for handling "' + params.tableName + '" found!');
			}
		}

		const uiMessageKeys = new Set();
		const result = new global.LFDocumentContentBuilder('v1', params.language, params.sysId, params.tableName, params);
		builder.build().getElements().forEach(element => {
			const fields = element.getFields().filter(field => {
				const params = field.getAdditionalParameters() || {};
				if (params.hasOwnProperty('type')) {
					// if not a UI Message: remove empty fields
					return !!field.getOriginalValue();
				}

				// remove duplicate UI messages
				const key = params.key || field.getOriginalValue();
				if (uiMessageKeys.has(key)) {
					return false;
				}
				
				uiMessageKeys.add(key);
				return true;		
			});

			element.setFields(fields);
			if (fields.length > 0) {
				result.processElement(element);
			}
		});

		return result.build();
	},

	_processDocumentation: function (builder, metadataGr, group, params) {
		const isTable = params.tableName == 'sys_db_object';
		const anyGr = new GlideRecord(isTable ? 'sys_db_object' : 'sys_dictionary');
		anyGr.addQuery('sys_id', metadataGr.getUniqueValue());
		if (!isTable) {
			anyGr.addNotNullQuery('element'); // this is probably redundant with the collection-condition
			anyGr.addQuery('internal_type', '!=', 'collection');
			anyGr.addQuery('element', '!=', '');
		}
		anyGr.setLimit(1);
		anyGr.query();
		if (anyGr.next()) {
			this.documentationProcessor.processDocumentation(builder, anyGr);
		}
	},

	_processUISection: function (builder, metadataGr, group, params) {
		const annotationSysIDs = [];
		const uiElementGr = new GlideRecord('sys_ui_element');
		uiElementGr.addQuery('type', 'annotation');
		uiElementGr.addQuery('sys_ui_section', metadataGr.getUniqueValue());
		uiElementGr.query();
		while (uiElementGr.next()) {
			annotationSysIDs.push(uiElementGr.getValue('element'));
		}

		const annotationGr = new GlideRecord('sys_ui_annotation');
		annotationGr.addQuery('sys_id', 'IN', annotationSysIDs);			
		annotationGr.query();
		while (annotationGr.next()) {
			const text = annotationGr.text.toString();
			if (text.includes('${')) {
				// annotation is taking care of the translations itself
				builder.processScript(text, group, 'Annotation', params);
			} else {
				const originalValue = builder._getOriginalMessage(text);
				const translatedValue = builder._getTranslatedValueFromStandardTables(text);
				const additionalParameters = {};
				if (text != originalValue) {
					additionalParameters['key'] = text;
				}

				const scope = builder._getScope(params);
				if (scope) {
					additionalParameters['scope'] = scope;
				}

				const element = global.LFDocumentContentHelper.createElement(group, 'Annotation');
				element.addField(
					global.LFDocumentContentHelper
						.createField(originalValue, translatedValue)
						.setAdditionalParameters(additionalParameters)
				);
				builder.processElement(element);
			}
		}
	},

	_processHTML: function (html) {
		// in-place translations via ${ MESSAGE {{DATA-BINDING}} } in 'Body HTML template'
		let i = html.indexOf('${'); let count = 0;
		let pcount = 0;
		let start = 0;
		const messages = [];
		while (i < html.length && i != -1) {
			if (count++ > html.length) {
				return null;
			}

			if (html[i] == '$' && html[i + 1] == '{' && (++pcount == 1)) {
				// beginning of message
				// Note: This won't throw if (i + 1) is out of bounds
				i += 2;
				start = i;
			} else if (html[i] == '{' && pcount > 0) {
				// regular open brace (only registered when we've started parsing)
				pcount++;
				i++;
			} else if (html[i] == '}' && pcount > 0 && (--pcount == 0)) {
				// if all braces closed, message is fully parsed
				messages.push(html.substring(start, i));
				i = html.indexOf('${', i);
			} else {
				i++;
			}
		}

		return [...new Set(messages)];
	},

	_getScriptFields: function (table) {
		return this._getTranslateableFields(table).filter(f => f.type.startsWith('script'));
	},

	_getHTMLFields: function (table) {
		return this._getTranslateableFields(table).filter(f => f.type.startsWith('html'));
	},

	_getTranslatedFields: function (table) {
		return this._getTranslateableFields(table).filter(f => f.type.startsWith('translated'));
	},
	
	_getTranslateableFields: function (table) {
		const fields = [];
		const dictionaryGr = new GlideRecord('sys_dictionary');
		dictionaryGr.addQuery('name', 'IN', new GlideTableHierarchy(table).getTables());
		dictionaryGr.addQuery('internal_type', 'translated_field')
			.addOrCondition('internal_type', 'translated_html')
			.addOrCondition('internal_type', 'translated_text')
			.addOrCondition('internal_type', 'html_template')
			.addOrCondition('internal_type', 'script')
			.addOrCondition('internal_type', 'script_server')
			.addOrCondition('internal_type', 'script_client')
			.addOrCondition('internal_type', 'script_plain');
		dictionaryGr.orderBy('name');
		dictionaryGr.orderBy('element');
		dictionaryGr.query();
		while (dictionaryGr.next()) {
			fields.push({
				table: dictionaryGr.getValue('name'),
				name: dictionaryGr.getValue('element'),
				label: dictionaryGr.getDisplayValue('column_label'),
				type: dictionaryGr.getValue('internal_type')
			});
		}
		
		return fields;
	},

	_extForTable: function (table) {
		for (let i = 0; i < this.extensionPoints.length; i++) {
			if (this.extensionPoints[i].handlesTable(table)) {
				return this.extensionPoints[i];
			}
		}
	},

	category: 'localization_framework',
    type: 'MetadataLocalizationProcessor'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2024-05-27 17:55:58</sys_created_on>
        <sys_id>feb8b32fc3d20610754fbfddd4013118</sys_id>
        <sys_mod_count>47</sys_mod_count>
        <sys_name>MetadataLocalizationProcessor</sys_name>
        <sys_package display_value="Localization Framework+ Scoped Apps" source="x_376096_lfp_apps">2e7fca8fc3924210754fbfddd401310d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Localization Framework+ Scoped Apps">2e7fca8fc3924210754fbfddd401310d</sys_scope>
        <sys_update_name>sys_script_include_feb8b32fc3d20610754fbfddd4013118</sys_update_name>
        <sys_updated_by>markus.kraus</sys_updated_by>
        <sys_updated_on>2024-05-31 21:00:44</sys_updated_on>
    </sys_script_include>
</record_update>
