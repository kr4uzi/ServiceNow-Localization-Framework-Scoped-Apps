<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_376096_lfp_apps.MetadataLocalizationProcessor</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Script that is used while processing or translating an artifact</description>
        <name>MetadataLocalizationProcessor</name>
        <script><![CDATA[/* global gs, global, x_376096_lfp_apps */
/* global Class, GlideAggregate, GlideRecord, GlideTableHierarchy, GlideScriptedExtensionPoint, Set */
/* eslint no-undef: "error" */
var MetadataLocalizationProcessor = Class.create();
MetadataLocalizationProcessor.prototype = Object.extendsObject(global.LFArtifactProcessorSNC, {
	saveTranslatedContent: function (documentContentObject) {
		global.LFArtifactProcessorSNC.prototype.saveTranslatedContent.apply(this, arguments);
		
		// the default save function is currently not handling sys_documentation fields at all...
		// the script below is based on LFReadSaveScriptUtils::saveTranslationsInStandardTables
		const targetLanguage = documentContentObject.getLanguage();
        const version = documentContentObject.getVersion();
        if (version == 'v1' && targetLanguage) {
			const elements = documentContentObject.getElements();
			const docFields = {};
			const choiceFields = {};
            for (let i = 0; i < elements.length; i++) {
				const fields = elements[i].getFields();
				for (let j = 0; j < fields.length; j++) {
					const field = fields[j];
					const fieldParams = field.getAdditionalParameters() || {};
					if (fieldParams.type == 'documentation_field' && fieldParams.sysId && fieldParams.name) {
						const docField = docFields[fieldParams.sysId] || (docFields[fieldParams.sysId] = {});
						docField[fieldParams.name] = field.getTranslatedValue();
					} else if (fieldParams.type == 'choice' && fieldParams.sysId
						&& fieldParams.hasOwnProperty('dependent') && fieldParams.value
						&& fieldParams.hasOwnProperty('field')) {
						choiceFields[fieldParams.sysId] ??= {};
						choiceFields[fieldParams.sysId][fieldParams.dependent] ??= {};
						choiceFields[fieldParams.sysId][fieldParams.dependent][fieldParams.value] ??= {};
						choiceFields[fieldParams.sysId][fieldParams.dependent][fieldParams.value][fieldParams.field] = field.getTranslatedValue();
					}
				}
            }

			const updateSetManager = new global.LFUpdateSetManager(this.publishMode, this.updateSetSuffix);
			const docGr = new GlideRecord('sys_documentation');
			docGr.addQuery('sys_id', 'IN', Object.keys(docFields));
			docGr.query();
			while (docGr.next()) {
				updateSetManager.switchToUpdateSetInScope(docGr.getValue('sys_scope'));
				this.docExt.createOrUpdateDocumention(docGr.getValue('name'), docGr.getValue('element'), targetLanguage, docFields[docGr.getUniqueValue()]);
				updateSetManager.switchToPreviousUpdateSet();
			}

			for (const choiceSetSysID in choiceFields) {
				const choiceSetGr = new GlideRecord('sys_choice_set');
				choiceSetGr.addQuery('sys_id', choiceSetSysID);
				choiceSetGr.setLimit(1);
				choiceSetGr.query();
				if (choiceSetGr.next()) {
					const table = choiceSetGr.getValue('name');
					const element = choiceSetGr.getValue('element');
					updateSetManager.switchToUpdateSetInScope(choiceSetGr.getValue('sys_scope'));
					for (const dependentValue in choiceFields[choiceSetSysID]) {
						for (const value in choiceFields[choiceSetSysID][dependentValue]) {
							this.choiceExt.createOrUpdateChoice(table, element, dependentValue, value, targetLanguage, choiceFields[choiceSetSysID][dependentValue][value]);
						}
					}
					updateSetManager.switchToPreviousUpdateSet();
				}
			}
        }
	},

	initialize: function () {try {
		global.LFArtifactProcessorSNC.prototype.initialize.apply(this, arguments);
		
		const metadataExts = new GlideScriptedExtensionPoint().getExtensions('LFPMetadataExt');
		if (metadataExts.length) {
			for (let i = 0; i < metadataExts.length; i++) {
				metadataExts[i].initialize();
			}

			this.metadataExts = metadataExts;
		} else {
			throw new Error(this.type + ' requires a "LFPMetadataExt" implementation');
		}

		const docExts = new GlideScriptedExtensionPoint().getExtensions('LFPDocumentationExt');
		if (docExts.length) {
			docExts[0].initialize();
			this.docExt = docExts[0];
		} else {
			throw new Error(this.type + ' requires a "LFPDocumentationExt" implementation');
		}

		const choiceExts = new GlideScriptedExtensionPoint().getExtensions('LFPChoiceExt');
		if (choiceExts.length) {
			choiceExts[0].initialize();
			this.choiceExt = choiceExts[0];
		} else {
			throw new Error(this.type + ' requires a "LFPChoiceExt" implementation');
		}

		this.documentationProcessor = new x_376096_lfp_apps.TableLocalizationProcessor();
		this.metadataHandlers = {
			'sys_ui_section': this._processUISection,
			'sys_db_object': this._processDocumentation,
			'sys_choice_set': this._processChoiceSet
		};

		new GlideTableHierarchy('sys_dictionary').getAllExtensions().forEach(x => {
			this.metadataHandlers[x] = this._processDocumentation;
		}); } catch (e) { gs.error("MKR init: " + e + "\n " + e.stack); }
	},
	
	showTranslateUIAction: function (recordGr) {
		const recordTable = recordGr.getRecordClassName();
		if (new global.LFUtils().showUIAction('lfp_apps_metadata')
			&& this._getTranslateableFields(recordTable).length > 0) {
			const uiActionGr = new GlideRecord('sys_ui_action');
			uiActionGr.addQuery('sys_id', '!=', '08d5d8ffc3560610754fbfddd4013158');
			uiActionGr.addQuery('active', true);
			uiActionGr.addQuery('name', 'Edit Translations');
			uiActionGr.addQuery('table', 'IN', new GlideTableHierarchy(recordTable).getTables());
			uiActionGr.setLimit(1);
			uiActionGr.query();
			// only show the translate ui action if no other 'Edit Translations' UI Action exists for the record's table
			return !uiActionGr.hasNext();
		}
		
		return false;
	},

    getTranslatableContent: function(params) {try {
		const builder = new global.LFDocumentContentBuilder('v1', params.language, params.sysId, params.tableName, params);
		const ext = this._metadataExtForTable(params.tableName);
		if (ext) {
			// Note: Not accessing the record's table is intentional to avoid creating cross scope privileges
			const recordGr = new GlideRecord('sys_metadata');
			recordGr.addQuery('sys_id', params.sysId);
			recordGr.setLimit(1);
			recordGr.query();
			if (recordGr.next()) {
				const displayValue = recordGr.getClassDisplayValue() + ': ' + (recordGr.getDisplayValue() || params.sysId);
				const scope = recordGr.getValue('sys_scope');

				const scriptFields = this._getScriptFields(params.tableName);
				const htmlFields = this._getHTMLFields(params.tableName);
				const fields = scriptFields.map(f => f.name)
					.concat(htmlFields.map(f => f.name));

				builder.processTranslatableFieldsForMultipleRecords(params.tableName, 'sys_id=' + params.sysId, displayValue, params);
				const data = ext.getFieldValues(params.tableName, recordGr.getUniqueValue(), fields);
				if (data) {
					scriptFields.forEach(f => builder.processScript(data[f.name], displayValue, f.label, params));
					htmlFields.forEach(f => {
						const messages = this._processHTML(data[f.name]);
						builder.processStringArray(messages, displayValue, f.label, params);
					});
				}

				this.metadataHandlers[params.tableName]?.call(this, builder, recordGr, displayValue, params);
			} else {
				gs.error('LF+ Scoped Apps: No Extension Point for handling "' + params.tableName + '" found!');
			}
		}

		const uiMessageKeys = new Set();
		const result = new global.LFDocumentContentBuilder('v1', params.language, params.sysId, params.tableName, params);
		builder.build().getElements().forEach(element => {
			const fields = element.getFields().filter(field => {
				const params = field.getAdditionalParameters() || {};
				if (params.hasOwnProperty('type')) {
					// if not a UI Message: remove empty fields
					return !!field.getOriginalValue();
				}

				// remove duplicate UI messages
				const key = params.key || field.getOriginalValue();
				if (uiMessageKeys.has(key)) {
					return false;
				}
				
				uiMessageKeys.add(key);
				return true;		
			});

			element.setFields(fields);
			if (fields.length > 0) {
				result.processElement(element);
			}
		});

		return result.build(); } catch (e) { gs.error("meta: " + e + "\n" + e.stack); }
	},

	_processChoiceSet: function (builder, metadataGr, group, params) {
		const choiceSetGr = new GlideRecord('sys_choice_set');
		choiceSetGr.addQuery('sys_id', metadataGr.getUniqueValue());
		choiceSetGr.setLimit(1);
		choiceSetGr.query();
		if (choiceSetGr.next()) {
			const table = choiceSetGr.getValue('name');
			const element = choiceSetGr.getValue('element');

			getDependentValues(table, element, [builder.sourceLanguage, builder.targetLanguage]).forEach(dependent => {
				const choiceGr = new GlideRecord('sys_choice');
				choiceGr.addQuery('name', table);
				choiceGr.addQuery('element', element);
				choiceGr.addQuery('inactive', false);
				choiceGr.addQuery('dependent_value', dependent);
				choiceGr.addQuery('language', builder.sourceLanguage)
					.addOrCondition('language', builder.targetLanguage);
				choiceGr.query();

				const choices = {};
				while (choiceGr.next()) {
					const value = choiceGr.value.toString();
					choices[value] ??= {};
					choices[value][choiceGr.language.toString()] = {
						label: choiceGr.label.toString(),
						hint: choiceGr.hint.toString()
					};
				}

				for (const value in choices) {
					const labelParams = {
						'sysId': choiceSetGr.getUniqueValue(),
						'type': 'choice',
						'dependent': dependent,
						'field': 'label',
						'value': value
					};

					const source = choices[value][builder.sourceLanguage];
					const target = choices[value][builder.targetLanguage];
					let elementGroup = `${choiceGr.getClassDisplayValue()}: ${value}`;
					if (dependent) {
						elementGroup += `[${dependent}]`;
					}
					elementGroup += ` (${table}.${element})`;

					builder.processElement(
						global.LFDocumentContentHelper.createElement(elementGroup, 'Label')
						.addField(global.LFDocumentContentHelper
							.createField(source.label, target?.label || '')
							.setAdditionalParameters(labelParams)
							.setTextType(global.LFDocumentContentHelper.PLAIN_TEXT_TYPE)
						)
					);

					if (source.hint) {
						const hintParams = JSON.parse(JSON.stringify(labelParams));
						hintParams.field = 'hint';

						element.addField(global.LFDocumentContentHelper
							.createField(source.hint, target?.hint || '')
							.setAdditionalParameters(hintParams)
							.setTextType(global.LFDocumentContentHelper.PLAIN_TEXT_TYPE));

						builder.processElement(
						global.LFDocumentContentHelper.createElement(elementGroup, 'Hint')
						.addField(global.LFDocumentContentHelper
							.createField(source.label, target?.label || '')
							.setAdditionalParameters(labelParams)
							.setTextType(global.LFDocumentContentHelper.PLAIN_TEXT_TYPE)
						)
					);
					}
				}
			});
		}

		function getDependentValues(table, field, languages) {
			const choiceGa = new GlideAggregate('sys_choice');
			choiceGa.addQuery('name', table);
			choiceGa.addQuery('element', field);
			choiceGa.addQuery('inactive', false);
			const qc = choiceGa.addQuery('language', languages[0]);
			languages.forEach(l => qc.addOrCondition('language', l));
			
			choiceGa.groupBy('dependent_value');
			choiceGa.query();

			const dependendValues = [];
			while (choiceGa.next()) {
				dependendValues.push(choiceGa.getValue('dependent_value'));
			}

			return dependendValues;
		}
	},

	_processDocumentation: function (builder, metadataGr, group, params) {
		const isTable = params.tableName == 'sys_db_object';
		const anyGr = new GlideRecord(isTable ? 'sys_db_object' : 'sys_dictionary');
		anyGr.addQuery('sys_id', metadataGr.getUniqueValue());
		if (!isTable) {
			anyGr.addNotNullQuery('element'); // this is probably redundant with the collection-condition
			anyGr.addQuery('internal_type', '!=', 'collection');
			anyGr.addQuery('element', '!=', '');
		}
		anyGr.setLimit(1);
		anyGr.query();
		if (anyGr.next()) {
			this.documentationProcessor.processDocumentation(builder, anyGr);
		}
	},

	_processUISection: function (builder, metadataGr, group, params) {
		const annotationSysIDs = [];
		const uiElementGr = new GlideRecord('sys_ui_element');
		uiElementGr.addQuery('type', 'annotation');
		uiElementGr.addQuery('sys_ui_section', metadataGr.getUniqueValue());
		uiElementGr.query();
		while (uiElementGr.next()) {
			annotationSysIDs.push(uiElementGr.getValue('element'));
		}

		const annotationGr = new GlideRecord('sys_ui_annotation');
		annotationGr.addQuery('sys_id', 'IN', annotationSysIDs);			
		annotationGr.query();
		while (annotationGr.next()) {
			const text = annotationGr.text.toString();
			if (text.includes('${')) {
				// annotation is taking care of the translations itself
				builder.processScript(text, group, 'Annotation', params);
			} else {
				const originalValue = builder._getOriginalMessage(text);
				const translatedValue = builder._getTranslatedValueFromStandardTables(text);
				const additionalParameters = {};
				if (text != originalValue) {
					additionalParameters['key'] = text;
				}

				const scope = builder._getScope(params);
				if (scope) {
					additionalParameters['scope'] = scope;
				}

				const element = global.LFDocumentContentHelper.createElement(group, 'Annotation');
				element.addField(
					global.LFDocumentContentHelper
						.createField(originalValue, translatedValue)
						.setAdditionalParameters(additionalParameters)
				);
				builder.processElement(element);
			}
		}
	},

	_processHTML: function (html) {
		// in-place translations via ${ MESSAGE {{DATA-BINDING}} } in 'Body HTML template'
		let i = html.indexOf('${'); let count = 0;
		let pcount = 0;
		let start = 0;
		const messages = [];
		while (i < html.length && i != -1) {
			if (count++ > html.length) {
				return null;
			}

			if (html[i] == '$' && html[i + 1] == '{' && (++pcount == 1)) {
				// beginning of message
				// Note: This won't throw if (i + 1) is out of bounds
				i += 2;
				start = i;
			} else if (html[i] == '{' && pcount > 0) {
				// regular open brace (only registered when we've started parsing)
				pcount++;
				i++;
			} else if (html[i] == '}' && pcount > 0 && (--pcount == 0)) {
				// if all braces closed, message is fully parsed
				messages.push(html.substring(start, i));
				i = html.indexOf('${', i);
			} else {
				i++;
			}
		}

		return [...new Set(messages)];
	},

	_getScriptFields: function (table) {
		return this._getTranslateableFields(table).filter(f => f.type.startsWith('script'));
	},

	_getHTMLFields: function (table) {
		return this._getTranslateableFields(table).filter(f => f.type.startsWith('html'));
	},

	_getTranslatedFields: function (table) {
		return this._getTranslateableFields(table).filter(f => f.type.startsWith('translated'));
	},
	
	_getTranslateableFields: function (table) {
		const fields = [];
		const dictionaryGr = new GlideRecord('sys_dictionary');
		dictionaryGr.addQuery('name', 'IN', new GlideTableHierarchy(table).getTables());
		dictionaryGr.addQuery('internal_type', 'translated_field')
			.addOrCondition('internal_type', 'translated_html')
			.addOrCondition('internal_type', 'translated_text')
			.addOrCondition('internal_type', 'html_template')
			.addOrCondition('internal_type', 'script')
			.addOrCondition('internal_type', 'script_server')
			.addOrCondition('internal_type', 'script_client')
			.addOrCondition('internal_type', 'script_plain');
		dictionaryGr.orderBy('name');
		dictionaryGr.orderBy('element');
		dictionaryGr.query();
		while (dictionaryGr.next()) {
			fields.push({
				table: dictionaryGr.getValue('name'),
				name: dictionaryGr.getValue('element'),
				label: dictionaryGr.getDisplayValue('column_label'),
				type: dictionaryGr.getValue('internal_type')
			});
		}
		
		return fields;
	},

	_metadataExtForTable: function (table) {
		for (let i = 0; i < this.metadataExts.length; i++) {
			if (this.metadataExts[i].handlesTable(table)) {
				return this.metadataExts[i];
			}
		}
	},

	category: 'localization_framework',
    type: 'MetadataLocalizationProcessor'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2024-05-27 17:55:58</sys_created_on>
        <sys_id>feb8b32fc3d20610754fbfddd4013118</sys_id>
        <sys_mod_count>89</sys_mod_count>
        <sys_name>MetadataLocalizationProcessor</sys_name>
        <sys_package display_value="Localization Framework+ Scoped Apps" source="x_376096_lfp_apps">2e7fca8fc3924210754fbfddd401310d</sys_package>
        <sys_policy/>
        <sys_scope display_value="Localization Framework+ Scoped Apps">2e7fca8fc3924210754fbfddd401310d</sys_scope>
        <sys_update_name>sys_script_include_feb8b32fc3d20610754fbfddd4013118</sys_update_name>
        <sys_updated_by>markus.kraus</sys_updated_by>
        <sys_updated_on>2024-06-02 00:13:11</sys_updated_on>
    </sys_script_include>
</record_update>
